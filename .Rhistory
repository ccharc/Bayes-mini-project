<<<<<<< HEAD
=======
}
f_xy <- function(x,y) return(f(c(x,y)))
clear
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
install.packages("magrittr")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages("imager")
#Load the image
img <- load.image("candy.jpg")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Load the image
img <- load.image("candy.jpg")
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("imager")
#Load the image
img <- load.image("candy.jpg")
detach("package:imager", unload=TRUE)
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
remove.packages("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
rm(list=ls())   #Delete old variables
graphics.off()  #Delete old plots
library("imager")
remove.packages("imager")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages(c("animation", "backports", "class", "codetools", "digest", "evaluate", "foreign", "jsonlite", "knitr", "lattice", "markdown", "MASS", "Matrix", "mgcv", "microbenchmark", "mime", "Rcpp", "rmarkdown", "Rmpfr", "stringi", "stringr", "survival", "tinytex", "xfun"))
library("imager")
install.packages("magrittr")
library("imager")
library("animation")
detach("package:animation", unload=TRUE)
install.packages("imager")
library("imager")
rm(list=ls())
graphics.off()
set.seed(2)
x=matrix(rnorm (50*2), ncol=2)
x[1:25,1]=x[1:25,1]+3
x[1:25,2]=x[1:25,2]-4
num = 1:50
hc.complete =hclust(dist(x), method="complete")
clust = cutree(hc.complete , 2)
par(mfrow = c(1,2))
par(mar=c(2,2,2,2))
plot(x , main="Data", xlab="", ylab="", type='n', xaxt='n',yaxt='n')
text(x[,1],x[,2],col=clust,labels =as.character(num), cex=0.4)
plot(hc.complete ,main="Complete Linkage", xlab="", ylab="",sub="", cex=.4, hang=-1)
data("iris")
kmeans(K=3, N=10)
?kmeans
kmeans(x, K=3, N=10)
kmeans(x,3,10)
load(iris)
?tail
head(iris)
(73.89-72.37)/72.37 *100
(94,49-71,86)/71.86*100
(94.49-71.86)/71.86*100
(91.88-71.86)/71.86*100
(91.31-71.86)/71.86*100
(101.54-71.86)/71.86*100
(73.75-71.86)/71.86*100
residuals.lm(dk1p)
residuals.lm(arima(dk1p))
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
plot(y)
acf(y)
diff(y)
x=diff(y)
acf(x)
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
plot(vartime())
plot(vartime(10))
plot(vartime())
adf?
?adf
clc
cleart
clear
?adf
adf.test?
adf.test
?adf.test
Qtilde=sparseMatrix(i=c(1:n),j=c(1:n),x=rep(phi,n))+Q
setwd("~/Desktop/MatØk6/Bayes-mini-project")
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
library(Matrix)
############################first part of selfstudy#############################
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
......
>>>>>>> 33b1bec898f9ad50f6c0e12752fdae7db95ce7fe
#Compute S
......
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
<<<<<<< HEAD
=======
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
?sparseMatrix
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
Qtilde=sparseMatrix(i=c(1:n),j=c(1:n),x=rep(phi,n))+Q
a=2*exp(theta[1])/(1+exp(theta[1]))-1
phi=exp(theta[2])
neg.log.profile.likelihood=function(theta,y,X,minimize=T){
a=2*exp(theta[1])/(1+exp(theta[1]))-1
phi=exp(theta[2])
#print(c(a,phi))
n=length(y)
#construct B and sqrt(D) as sparse matrices
......................
#Compute Q and Qtilde (again as sparse matrices
...................
Qtilde=sparseMatrix(i=c(1:n),j=c(1:n),x=rep(phi,n))+Q
#compute Cholesky factorization
CholQtilde=chol(Qtilde)
#compute \hat \beta(\theta)
#(X^T W^{-1} X)^{-1} X^\T W^{-1} y
#using Cholesky factor CholQtilde
...........................................
#check when n small
#Winv=solve(Qtilde)%*%Q
#betahat=solve(t(X)%*%Winv%*%X)%*%t(X)%*%Winv%*%y#OK
#compute \hat \sigma^2(\theta)
residual=y-X%*%betahat
.................................
sigma2hat=sum(residual*z)/n
#check
#z3=Winv%*%residual
#sigma2hat=sum(residual*z3)/n
#sigma2hat
#compute log likelihood. Note: determinant returns log determinant of original matrix.
#check (only for small n)
#V=sigma2hat*(diag(rep(1,n))+solve(Q)*phi)
#-log(det(V))/2#-1.92
#Vinv=solve(Qtilde)%*%Q/sigma2hat#OK
#detVinv=det(Q)/(det(Qtilde)*sigma2hat^n)
#logdetVinvhalf=log(det(Q))/2-log(det(Qtilde))/2-n*log(sigma2hat)/2
detQ=...
loglikelihood=-n*log(sigma2hat)/2-determinant(CholQtilde)$modulus+log(detQ)/2
#return negative log likelihood for later use with optim() which minimizes as default.
if (minimize)
return(-loglikelihood)
else
return(list(-loglikelihood,betahat,sigma2hat))
}
Qtilde=sparseMatrix(i=c(1:n),j=c(1:n),x=rep(phi,n))+Q
#compute Cholesky factorization
CholQtilde=chol(Qtilde)
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1,2,3,4,5),j=c(1,2,3,4,5),x=c(1,1,1,1,1),dims=c(5,5))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1,2,3,4,5),j=c(1,2,3,4,5),x=c(1,1,1,1,1),dims=c(n,n))
n=5
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1,2,3,4,5),j=c(1,2,3,4,5),x=c(1,1,1,1,1),dims=c(n,n))
B1
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1,2,3,4,5),x=c(1,1,1,1,1),dims=c(n,n))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(1,1,1,1,1),dims=c(n,n))
B1
n=6
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(1,1,1,1,1),dims=c(n,n))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(rep(n)),dims=c(n,n))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(n),dims=c(n,n))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(1),dims=c(n,n))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,n+1),j=c(1:n,n+1),x=c(1),dims=c(n,n))
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n,n+1),x=c(1),dims=c(n,n))
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(1),dims=c(n,n))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(1),dims=c(n,n), triangular = TRUE)
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(1),dims=c(n,n), triangular = TRUE, i=c(2:n),j=c(2:n), x=c(-a))
B1
a=3
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n),j=c(1:n,2:n),x=c(rep(1,n),rep(a,n)),dims=c(n,n), triangular = TRUE, i=c(2:n),j=c(2:n), x=c(-a))
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n),j=c(1:n,2:n),x=c(rep(1,n),rep(a,n)),dims=c(n,n), triangular = TRUE)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n-1),j=c(1:n,2:n-1),x=c(rep(1,n),rep(a,n)),dims=c(n,n), triangular = TRUE)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n-1),j=c(1:n,2:n-1),x=c(rep(1,n),rep(a,n-1)),dims=c(n,n), triangular = TRUE)
B1
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(rep(1,n)),dims=c(n,n), triangular = TRUE, i_k=c(2:n-1),  j_k=c(2:n-1), x=c(rep(a,n-1)))
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(rep(1,n)),dims=c(n,n), triangular = TRUE, i_k=c(2:n-1),  j_k=c(2:n-1), x_k=c(rep(a,n-1)))
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n),j=c(1:n),x=c(rep(1,n)),dims=c(n,n), triangular = TRUE, i_k=c(2:n-1),  j_k=c(1:n), x_k=c(rep(a,n-1)))
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n-1),j=c(1:n,1:n),x=c(rep(1,n),rep(a,n-1)),dims=c(n,n), triangular = TRUE)
B1
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
n=5
a=0.5
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n)) #f?rste
D1
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2)))) #de andres
D3 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1)))) #s?dan som jeg ville mene de andres skal v?re
#forst?r ikke hvorfor den ikke skal have udregnet det i alle indgange, og ikke kun den f?rste...
D2
D3
library("matlib", lib.loc="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
library("Matrix", lib.loc="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
library(Matrix)
############################first part of selfstudy#############################
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)*detS)
}else{
loglikelihood = logLik(fit)*detS
return(list(loglikelihood,fit))
}
}
#simulate data
n=10000
a=0.5
tau2=1
Droot = inv(sqDinv)
nu=sqrt(tau2)* sqDinv %*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
#simulate data
n=10000
a=0.5
tau2=1
Droot = inv(sqDinv)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
Droot = inv(sqDinv)
nu=sqrt(tau2)* sqDinv %*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
library(Matrix)
############################first part of selfstudy#############################
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
>>>>>>> 33b1bec898f9ad50f6c0e12752fdae7db95ce7fe
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)*detS)
}else{
loglikelihood = logLik(fit)*detS
return(list(loglikelihood,fit))
}
}
#simulate data
n=10000
a=0.5
tau2=1
Droot = inv(sqDinv)
nu=sqrt(tau2)* sqDinv %*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
library(Matrix)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)*detS)
}else{
loglikelihood = logLik(fit)*detS
return(list(loglikelihood,fit))
}
}
#simulate data
n=10000
a=0.5
a=0.5
a=0.5
a=0.5
a=0.5
tau2=1
Droot = inv(sqDinv)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
n=length(y)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)*detS)
}else{
loglikelihood = logLik(fit)*detS
return(list(loglikelihood,fit))
}
}
profile.likelihood(afit$maximum,y,X,maximize=F)
library(Matrix)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit))
}else{
loglikelihood = logLik(fit)
return(list(loglikelihood,fit))
}
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
S = sqDinv %*% B1
Droot = solve(sqDinv)
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
U=solve(B1,nu)#This corresponds to computing U=B eps
plot(U,type="l")
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
summary(afit)
n=20
a=0
tau2=1
Droot = solve(sqDinv)
nu=sqrt(tau2)*Droot%*%rnorm(n)
U=solve(B1,nu)
plot(U,type="l")
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
<<<<<<< HEAD
D2 = sqrt(sparseMatrix((i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n-1))))))
D2 = sqrt(sparseMatrix((i=c(1:n), j=c(1:n), x=c(1-a^2),rep(1,(n-1)))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(1-a^2),rep(1,(n-1))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(1-a^2),rep(1,(n-1))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n-1)))))
D2
D2
n=5
a=4
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n))
D1
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n-1)))))
D2
S = D1 * B1
S
S = D2 * B1
S
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n)))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
D2
a=0.5
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
D2
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n))
D1
D3 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
D3
library(Matrix)
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
n=5
a=0.5
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n)) #første
D1
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2)))) #de andres
D3 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1)))) #sådan som jeg ville mene de andres skal være
#forstår ikke hvorfor den ikke skal have udregnet det i alle indgange, og ikke kun den første...
D3
D2
)#Compute S
S = D2 * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n)) #første
D1
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2)))) #de andres
D3 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1)))) #sådan som jeg ville mene de andres skal være
#forstår ikke hvorfor den ikke skal have udregnet det i alle indgange, og ikke kun den første...
D3
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=det(S)
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
profile.likelihood=function(a,y,X,maximize=T){
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
#Compute S
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=det(S)
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#take a look at A
A
n=5
a=0.5
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
#Compute S
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=det(S)
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
return(logLik(fit)*detS)
fit=lm(ytilde~-1+Xtilde)
library(Matrix)
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
n=5
a=0.5
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
#Compute S
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
#compute determinant of S
detS=det(S)
if
return(logLik(fit)*detS)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
?summary
summary(fit)$variance
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
e
1+2
view(a)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
View(A)
setwd("~/Bayes/Bayes-mini-project")
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){}
return(logLik(fit))}
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
view(a)
1+2
e^2
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit))
}else{
loglikelihood = logLik(fit)
return(list(loglikelihood,fit))
}
}
=======
>>>>>>> 33b1bec898f9ad50f6c0e12752fdae7db95ce7fe
