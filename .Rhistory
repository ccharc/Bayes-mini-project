#Compute S
......
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
B4 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a, n-1), dims=c(n,n))
B4
B4
B4 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a, n-1), dims=c(n,n))
B4 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a, n-1), dims=c(n,n))
#Compute S
......
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
B4 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a, n-1), dims=c(n,n))
}
#Compute S
......
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n))
B1
B1
n=5
a=4
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n))
B1
B2 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a,n-1)), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n-1), j=c(1:n-1), x=c(rep(a,n-1)), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n), j=c(1:n), x=c(rep(a,n)), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n), j=c(1:n), x=c(a), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(a), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(a), dims=c(n,n))
B2
B2 = sparseMatrix(i=c(2:n), j=c(i+1:n), x=c(a), dims=c(n,n))
B2 = sparseMatrix(i_k=c(2:n), j_k=c(k+1:n), x=c(a), dims=c(n,n))
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n) Diagonal=True)
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n), Diagonal=True)
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n), Diagonal=TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1:n), x=c(rep(1,n-1)), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n), j=c(1:n), x=c(a), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(a), dims=c(n,n))
B2
B2 = sparseMatrix(i=c(2:n), j=c(1:2), x=c(a), dims=c(n,n))
B2 = sparseMatrix(i=c(2:n), j=c(1:2), x=c(a), dims=c(n,n))
?`dgTMatrix-class`
?`dgTMatrix-class`
B2 = sparseMatrix(i=c(2:n), j=c(1:2), x=c(a), dims=c(n,n), triangluar = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1:2), x=c(a), dims=c(n,n), Triangluar = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1:2), x=c(a), dims=c(n,n), Triag = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1:2), x=c(a), dims=c(n,n), Tri = TRUE)
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n), triangular = =TRUE)
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(1:n), j=c(2:n), x=c(rep(a, n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(1:n), j=c(2), x=c(rep(a, n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(a, dims=c(n,n), triangular = TRUE)
#Compute S
......
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(a, dims=c(n,n), triangular = TRUE)
#Compute S
......
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(a), dims=c(n,n), triangular = TRUE)
B2
n=5
B1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1,n)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(a), dims=c(n,n), triangular = TRUE)
B2
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(rep(a,n), dims=c(n,n), triangular = TRUE)
B2
#Compute S
......
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(rep(a,n)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2
n=5
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2
a=4
B2 = sparseMatrix(i=c(2:n), j=c(2:n), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2
B2 = sparseMatrix(i=c(2:n), j=c(1:n), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a,n-2)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1:n-1), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(1+1:n-1), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(n:2), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n), j=c(n), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(n), j=c(n), x=c(rep(a)), dims=c(n,n), triangular = TRUE)
B2
B2 = sparseMatrix(i=c(2:n-1), j=c(2:n), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2
B2 = sparseMatrix(i=c(1:n), j=c(n+1:n-1), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2 = sparseMatrix(i=c(2:n-1), j=c(2:n), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2
B2 = sparseMatrix(i=c(2:n), j=(2:n-1), x=c(rep(a,n-1)), dims=c(n,n), triangular = TRUE)
B2
B3 = B1+B2
B3
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(a, n-1)), dims=c(n,n), triangular = TRUE)
B1
D1 = sparseMatrix(i=c(1:n), j=c(1:n),x=c(rep(sqrt(a),n)), dims=c(n,n))
D1
#Compute S
S = D1 * B1
S
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
D1 = sparseMatrix(i=c(1:n), j=c(1:n),x=c(rep(sqrt(-a),n)), dims=c(n,n))
D1 = sparseMatrix(i=c(1:n), j=c(1:n),x=c(rep(-sqrt(a),n)), dims=c(n,n))
D1 = sparseMatrix(i=c(1:n), j=c(1:n),x=c(rep(1-a^2),n)), dims=c(n,n))
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2, n)), dims=c(n,n))
D1 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2, n)), dims=c(n,n)))
D1 = (sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2, n)), dims=c(n,n)))
D1
D1 = (sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(sqrt(1-a^2), n)), dims=c(n,n)))
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n))
D1
D2 = sqrt(sparseMatrix((i=c(1:n), j=c(1:n), x=c((1-a^2), rep(1, (n-1))))
D2 = sqrt(sparseMatrix((i=c(1:n), j=c(1:n), x=c((1-a^2), rep(1, (n-1)))
D2 = sqrt(sparseMatrix((i=c(1:n), j=c(1:n), x=c((1-a^2), rep(1, (n-1)))))
#Compute S
S = D1 * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#simulate data
n=10000
a=0.5
tau2=1
nu=sqrt(tau2)*Droot%*%rnorm(n)#Droot inverse of Dinvroot and Binv defined as above
U=solve(Binv,nu)#This corresponds to computing U=B eps
#Ucheck=solve(Binv)%*%eps  don't do this if n is large ! B is not sparse !!
plot(U,type="l")#take a look at simulated errors
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
profile.likelihood(afit$maximum,y,X,maximize=F)
D2 = sqrt(sparseMatrix((i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n-1))))))
D2 = sqrt(sparseMatrix((i=c(1:n), j=c(1:n), x=c(1-a^2),rep(1,(n-1)))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(1-a^2),rep(1,(n-1))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(1-a^2),rep(1,(n-1))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n-1)))))
D2
D2
n=5
a=4
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n))
D1
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n-1)))))
D2
S = D1 * B1
S
S = D2 * B1
S
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,(n)))))
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
D2
a=0.5
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
D2
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n))
D1
D3 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
D3
library(Matrix)
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
n=5
a=0.5
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n)) #første
D1
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2)))) #de andres
D3 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1)))) #sådan som jeg ville mene de andres skal være
#forstår ikke hvorfor den ikke skal have udregnet det i alle indgange, og ikke kun den første...
D3
D2
)#Compute S
S = D2 * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=......
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
D1 = sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(-sqrt(a), n)), dims=c(n,n)) #første
D1
D2 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2)))) #de andres
D3 = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1)))) #sådan som jeg ville mene de andres skal være
#forstår ikke hvorfor den ikke skal have udregnet det i alle indgange, og ikke kun den første...
D3
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=det(S)
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
profile.likelihood=function(a,y,X,maximize=T){
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
#Compute S
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=det(S)
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
#take a look at A
A
n=5
a=0.5
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
n=length(y)
#construct B^{-1} and sqrt(D^{-1}) - both as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
#Compute S
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
fit=lm(ytilde~-1+Xtilde)
#compute determinant of S
detS=det(S)
if (maximize)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a as well as fitted coeffiecients and variance
}
return(logLik(fit)*detS)
fit=lm(ytilde~-1+Xtilde)
library(Matrix)
#how to define sparse 5 x 5 matrix A with 1 and 2 at entries [2,3] and [5,5]
A=sparseMatrix(i=c(2,5),j=c(3,5),x=c(1,2),dims=c(5,5))
#take a look at A
A
n=5
a=0.5
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
#Compute S
S = sqDinv * B1
S
ytilde=as.numeric(S%*%y)#some conversions of formats needed so that lm() is happy (wants data to be of type numeric and design matrix Xtilde to be of ordinary matrix type)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))#why add column of ones ?
#compute determinant of S
detS=det(S)
if
return(logLik(fit)*detS)
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
#return likelihood of data y given a (NB log likelihood for ytilde can be extracted using logLik(fit))
else
?summary
summary(fit)$variance
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
e
1+2
view(a)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
View(A)
setwd("~/Bayes/Bayes-mini-project")
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T){
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){}
return(logLik(fit))}
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
view(a)
1+2
e^2
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
B1
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c(rep(1-a^2))))
sqDinv
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit))
}else{
loglikelihood = logLik(fit)
return(list(loglikelihood,fit))
}
}
