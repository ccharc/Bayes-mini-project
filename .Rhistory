library("imager")
#Load the image
img <- load.image("candy.jpg")
detach("package:imager", unload=TRUE)
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
remove.packages("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
rm(list=ls())   #Delete old variables
graphics.off()  #Delete old plots
library("imager")
remove.packages("imager")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages(c("animation", "backports", "class", "codetools", "digest", "evaluate", "foreign", "jsonlite", "knitr", "lattice", "markdown", "MASS", "Matrix", "mgcv", "microbenchmark", "mime", "Rcpp", "rmarkdown", "Rmpfr", "stringi", "stringr", "survival", "tinytex", "xfun"))
library("imager")
install.packages("magrittr")
library("imager")
library("animation")
detach("package:animation", unload=TRUE)
install.packages("imager")
library("imager")
rm(list=ls())
graphics.off()
set.seed(2)
x=matrix(rnorm (50*2), ncol=2)
x[1:25,1]=x[1:25,1]+3
x[1:25,2]=x[1:25,2]-4
num = 1:50
hc.complete =hclust(dist(x), method="complete")
clust = cutree(hc.complete , 2)
par(mfrow = c(1,2))
par(mar=c(2,2,2,2))
plot(x , main="Data", xlab="", ylab="", type='n', xaxt='n',yaxt='n')
text(x[,1],x[,2],col=clust,labels =as.character(num), cex=0.4)
plot(hc.complete ,main="Complete Linkage", xlab="", ylab="",sub="", cex=.4, hang=-1)
data("iris")
kmeans(K=3, N=10)
?kmeans
kmeans(x, K=3, N=10)
kmeans(x,3,10)
load(iris)
?tail
head(iris)
(73.89-72.37)/72.37 *100
(94,49-71,86)/71.86*100
(94.49-71.86)/71.86*100
(91.88-71.86)/71.86*100
(91.31-71.86)/71.86*100
(101.54-71.86)/71.86*100
(73.75-71.86)/71.86*100
residuals.lm(dk1p)
residuals.lm(arima(dk1p))
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
plot(y)
acf(y)
diff(y)
x=diff(y)
acf(x)
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
plot(vartime())
plot(vartime(10))
plot(vartime())
adf?
?adf
clc
cleart
clear
?adf
adf.test?
adf.test
?adf.test
#reparametrization so we are sure to have positive phi and |a|<1
#theta=(logit((a+1)/2),log(phi))
#if A=t(R)%*%R then we can compute z=A^{-1}x by solving Az=x wrt. z. That is
#first temp=solve(t(R),x) and secondly z=solve(R,temp)
neg.log.profile.likelihood=function(theta,y,X,minimize=T){
a=2*exp(theta[1])/(1+exp(theta[1]))-1
phi=exp(theta[2])
#print(c(a,phi))
n=length(y)
#construct B and sqrt(D) as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
#Compute Q and Qtilde (again as sparse matrices)
Q  = t(B1)%*%sqDinv%*%B1
Qtilde=sparseMatrix(i=c(1:n),j=c(1:n),x=rep(phi,n))+Q
#compute Cholesky factorization
CholQtilde=chol(Qtilde)
#compute \hat \beta(\theta)
#(X^T W^{-1} X)^{-1} X^\T W^{-1} y
#using Cholesky factor CholQtilde
w = Q%*%y
x = solve(t(CholQtilde),w)
WinvY= solve(CholQtilde,x)
w = Q%*%X
x = solve(t(CholQtilde),w)
WinvX= solve(CholQtilde,x)
betahat = solve(t(X) %*% WinvX) %*% t(X) %*%  WinvY
#check when n small
#Winv=solve(Qtilde)%*%Q
#betahat=solve(t(X)%*%Winv%*%X)%*%t(X)%*%Winv%*%y#OK
#compute \hat \sigma^2(\theta)
residual=y-X%*%betahat
w = Q%*%residual
x = solve(t(CholQtilde),w)
WinvRes= solve(CholQtilde,x)
sigma2hat=sum(residual*WinvRes)/n
#check
#z3=Winv%*%residual
#sigma2hat=sum(residual*z3)/n
#sigma2hat
#compute log likelihood. Note: determinant returns log determinant of original matrix.
#check (only for small n)
#V=sigma2hat*(diag(rep(1,n))+solve(Q)*phi)
#-log(det(V))/2#-1.92
#Vinv=solve(Qtilde)%*%Q/sigma2hat#OK
#detVinv=det(Q)/(det(Qtilde)*sigma2hat^n)
#logdetVinvhalf=log(det(Q))/2-log(det(Qtilde))/2-n*log(sigma2hat)/2
detQ=det(Q)
loglikelihood=-n*log(sigma2hat)/2-determinant(CholQtilde)$modulus+log(detQ)/2
#return negative log likelihood for later use with optim() which minimizes as default.
if (minimize)
return(-loglikelihood)
else
return(list(-loglikelihood,betahat,sigma2hat))
}
#simulate data
n=10000
a=0.5
tau2=0.25
sigma2=1
ii=c(1:n,2:n)
jj=c(1:n,1:(n-1))
Binvij=c(rep(1,n),rep(-a,n-1))
Binv=sparseMatrix(i=ii,j=jj,x=Binvij,dims=c(n,n))
Droot=sparseMatrix(i=c(1:n),j=c(1:n),x=sqrt(c(1/(1-a^2),rep(1,n-1))))
nu=sqrt(tau2)*Droot%*%rnorm(n)
U=solve(Binv,nu)
plot(U,type="l")
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=cbind(rep(1,n),x)
y=3+2*x+U+rnorm(n,sd=sqrt(sigma2))
tempa=(a+1)/2
thetastart=c(log(tempa/(1-tempa)),log(tau2/sigma2))
neg.log.profile.likelihood(thetastart,y,X,minimize=F)
tempa=(0.3+1)/2
thetastart=c(log(tempa/(1-tempa)),log(1))
thetafit=optim(thetastart,neg.log.profile.likelihood,y=y,X=X)
thetafit
ahat=2*exp(thetafit$par[1])/(1+exp(thetafit$par[1]))-1
phihat=exp(thetafit$par[2])
tempa=(ahat+1)/2
thetastart=c(log(tempa/(1-tempa)),log(phihat))
neg.log.profile.likelihood(thetastart,y,X,minimize=F)
neg.log.profile.likelihood=function(theta,y,X,minimize=T){
a=2*exp(theta[1])/(1+exp(theta[1]))-1
phi=exp(theta[2])
#print(c(a,phi))
n=length(y)
#construct B and sqrt(D) as sparse matrices
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
#Compute Q and Qtilde (again as sparse matrices)
Q  = t(B1)%*%sqDinv%*%B1
Qtilde=sparseMatrix(i=c(1:n),j=c(1:n),x=rep(phi,n))+Q
#compute Cholesky factorization
CholQtilde=chol(Qtilde)
#compute \hat \beta(\theta)
#(X^T W^{-1} X)^{-1} X^\T W^{-1} y
#using Cholesky factor CholQtilde
w = Q%*%y
x = solve(t(CholQtilde),w)
WinvY= solve(CholQtilde,x)
w = Q%*%X
x = solve(t(CholQtilde),w)
WinvX= solve(CholQtilde,x)
betahat = solve(t(X) %*% WinvX) %*% t(X) %*%  WinvY
#check when n small
#Winv=solve(Qtilde)%*%Q
#betahat=solve(t(X)%*%Winv%*%X)%*%t(X)%*%Winv%*%y#OK
#compute \hat \sigma^2(\theta)
residual=y-X%*%betahat
w = Q%*%residual
x = solve(t(CholQtilde),w)
WinvRes= solve(CholQtilde,x)
sigma2hat=sum(residual*WinvRes)/n
#check
#z3=Winv%*%residual
#sigma2hat=sum(residual*z3)/n
#sigma2hat
#compute log likelihood. Note: determinant returns log determinant of original matrix.
#check (only for small n)
#V=sigma2hat*(diag(rep(1,n))+solve(Q)*phi)
#-log(det(V))/2#-1.92
#Vinv=solve(Qtilde)%*%Q/sigma2hat#OK
#detVinv=det(Q)/(det(Qtilde)*sigma2hat^n)
#logdetVinvhalf=log(det(Q))/2-log(det(Qtilde))/2-n*log(sigma2hat)/2
detQ=det(Q)
loglikelihood=-n*log(sigma2hat)/2-determinant(CholQtilde)$modulus+log(detQ)/2
#return negative log likelihood for later use with optim() which minimizes as default.
if (minimize)
return(-loglikelihood)
else
return(list(-loglikelihood,betahat,sigma2hat))
}
#simulate data
n=10000
a=0.5
tau2=0.25
sigma2=1
ii=c(1:n,2:n)
jj=c(1:n,1:(n-1))
Binvij=c(rep(1,n),rep(-a,n-1))
Binv=sparseMatrix(i=ii,j=jj,x=Binvij,dims=c(n,n))
Droot=sparseMatrix(i=c(1:n),j=c(1:n),x=sqrt(c(1/(1-a^2),rep(1,n-1))))
nu=sqrt(tau2)*Droot%*%rnorm(n)
library(Matrix)
n=10000
a=0.5
tau2=0.25
sigma2=1
ii=c(1:n,2:n)
jj=c(1:n,1:(n-1))
Binvij=c(rep(1,n),rep(-a,n-1))
Binv=sparseMatrix(i=ii,j=jj,x=Binvij,dims=c(n,n))
Droot=sparseMatrix(i=c(1:n),j=c(1:n),x=sqrt(c(1/(1-a^2),rep(1,n-1))))
nu=sqrt(tau2)*Droot%*%rnorm(n)
U=solve(Binv,nu)
plot(U,type="l")
mean(U)
var(as.numeric(U))
acf(as.numeric(U))
x=rnorm(n)
X=cbind(rep(1,n),x)
y=3+2*x+U+rnorm(n,sd=sqrt(sigma2))
tempa=(a+1)/2
thetastart=c(log(tempa/(1-tempa)),log(tau2/sigma2))
neg.log.profile.likelihood(thetastart,y,X,minimize=F)
tempa=(0.3+1)/2
thetastart=c(log(tempa/(1-tempa)),log(1))
thetafit=optim(thetastart,neg.log.profile.likelihood,y=y,X=X)
thetafit
ahat=2*exp(thetafit$par[1])/(1+exp(thetafit$par[1]))-1
phihat=exp(thetafit$par[2])
tempa=(ahat+1)/2
thetastart=c(log(tempa/(1-tempa)),log(phihat))
neg.log.profile.likelihood(thetastart,y,X,minimize=F)
library(readxl)
library(vars)
library(imputeTS)
library(forecast)
library(tseries)
library(stats)
data =  data.frame(read.csv("elconsdata.csv",sep=";"), "numeric")
setwd("~/Desktop/MatÃ˜k6/Bayes-mini-project")
data =  data.frame(read.csv("elconsdata.csv",sep=";"), "numeric")
y = data[,1]
View(data)
y
data =  data.frame(read.csv("elconsdata.csv",sep=";"))
y = data[,1]
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit))
}else{
loglikelihood = logLik(fit)
return(list(loglikelihood,fit))
}
}
y
X = data[,2:3]
X
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit))
}else{
loglikelihood = logLik(fit)
return(list(loglikelihood,fit))
}
}
View(profile.likelihood)
profile.likelihood(0.5,y,X)
library(Matrix)
library(Matrix)
profile.likelihood(0.5,y,X)
profile.likelihood(0.5,y,X)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)detS)
}else{
loglikelihood = logLik(fit)detS
return(list(loglikelihood,fit))
}
}
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)*detS)
}else{
loglikelihood = logLik(fit)*detS
return(list(loglikelihood,fit))
}
}
veca = c(0,0.5,0.99)
vecn = c(20,1000)
simu = 100
for (k in 1:length(vecn)) {
for (j in 1: length(veca)){
beta1 = c()
beta2 = c()
tau1 = c()
for (i in 1:simu) {
n = vecn[k]
a = veca[j]
tau2=1
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
Droot = sqrt(sparseMatrix(i=c(1:n),j=c(1:n),x=c(1/(1-a^2),rep(1,(n-1)))))
nu=sqrt(tau2)*Droot%*%rnorm(n)
U=solve(B1,nu)
x=rnorm(n)
X=matrix(x,ncol=1)
y=3+2*x+U
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
logL = profile.likelihood(afit$maximum,y,X,maximize=F)
beta = coef(logL[[2]])
beta1[i] = beta[[1]]
beta2[i] = beta[[2]]
tau1[i] = summary(logL[[2]])$sigma
}
par(mfrow=c(1,3))
qqnorm(beta1)
qqline(beta1)
qqnorm(beta2)
qqline(beta2)
qqnorm(tau1)
qqline(tau1)
filename=paste("plot",format(k),format(j),".pdf",sep="")
dev.copy2pdf(file=filename)
}
}
a=0.5
profile.likelihood(0.5,y,X)
profile.likelihood(a,y,X)
data =  data.frame(read.csv("elconsdata.csv",sep=";"))
y = data[,1]
X = data[,2:3]
a=0.5
fit1 = profile.likelihood(a,y,X)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
S = sqDinv %*% B1
S
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)*detS)
}else{
loglikelihood = logLik(fit)*detS
return(list(loglikelihood,fit))
}
}
fit1 = profile.likelihood(a,y,X)
y = as.matrix(data[,1])
X = as.matrix(data[,2:3])
a=0.5
fit1 = profile.likelihood(a,y,X)
summary(fit1)
data =  data.frame(read.csv("elconsdata.csv",sep=";"))
y = as.matrix(data[,1])
X = as.matrix(data[,2:3])
a=0.5
fit1 = profile.likelihood(a,y,X)
#skeleton for profile likelihood procedure
profile.likelihood=function(a,y,X,maximize=T) {
n=length(y)
B1 = sparseMatrix(i=c(1:n,2:n), j=c(1:n,2:n-1), x=c(rep(1,n),rep(-a, n-1)), dims=c(n,n), triangular = TRUE)
sqDinv = sqrt(sparseMatrix(i=c(1:n), j=c(1:n), x=c((1-a^2),rep(1,n-1))))
S = sqDinv %*% B1
ytilde=as.numeric(S%*%y)
Xtilde=as.matrix(S%*%cbind(rep(1,n),X))
fit=lm(ytilde~-1+Xtilde)
detS=det(S)
if (maximize){
return(logLik(fit)*detS)
}else{
loglikelihood = logLik(fit)*detS
return(list(loglikelihood,fit))
}
}
fit1 = profile.likelihood(a,y,X)
summary(fit1)
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
logL = profile.likelihood(afit$maximum,y,X,maximize=F)
beta = coef(LogL)
fit1 = profile.likelihood(a,y,X)
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
logL = profile.likelihood(afit$maximum,y,X,maximize=F)
beta = coef(LogL)
beta = coef(LogL[[2]])
logL1 = profile.likelihood(afit$maximum,y,X,maximize=F)
beta = coef(LogL1[[2]])
summary(logL1)
summary(afit)
logL1 = profile.likelihood(afit$maximum,y,X,maximize=F)
logL1
afit
fit1
beta[i] = coef(logL1[[2]])
beta = coef(logL1[[2]])
beta
tau = summary(logL[[2]])$sigma
tau
sigma = summary(logL[[2]])$sigma
sigma
lm(y~X)
signnn = summary(fit[[2]])$sigma
fit = lm(y~X)
signnn = summary(fit[[2]])$sigma
signnn = summary(fit[2])$sigma
summary(fit)
fit1 = profile.likelihood(a,y,X)
afit=optimize(profile.likelihood,interval=c(-1,1),y=y,X=X,maximum=T)
logL1 = profile.likelihood(afit$maximum,y,X,maximize=F)
beta = coef(logL1[[2]])
beta
sigma = summary(logL[[2]])$sigma
sigma
VAR(y ~X)
var(y ~X)
neg.log.profile.likelihood=function(theta,y,X,minimize=T)
neg.log.profile.likelihood(theta,y,X,minimize=T)
mod = neg.log.profile.likelihood(theta,y,X,minimize=T)
